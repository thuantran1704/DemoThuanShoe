'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var reactRange = require('react-range');
var react = require('@stitches/react');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var aspectRatioRegex = /*#__PURE__*/new RegExp(/(\d+)(:|x)(\d+)/);
function calculateAspectRatio(ratio) {
  var asNumber = Number(ratio);
  var asString = String(ratio);
  var isNumber = !isNaN(asNumber);

  if (isNumber) {
    return 1 / asNumber * 100;
  } else {
    var match = asString.match(aspectRatioRegex);
    if (!match) throw Error('Please use a valid aspect ratio delimeter, either "x" or ":"');
    var width = Number(match[1]);
    var height = Number(match[3]);
    return height / width * 100;
  }
}
function isFunction(functionToCheck) {
  return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
}

var _excluded = ["isFocused"];
var PinnedDiv = /*#__PURE__*/react.styled('div', {
  width: '100%',
  height: '100%',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  position: 'absolute'
});
var Track = /*#__PURE__*/react.styled(PinnedDiv, {
  background: 'transparent',
  zIndex: 10
});
var RangeWrap = PinnedDiv;
var Element = /*#__PURE__*/react.styled(PinnedDiv, {
  '> *': {
    height: '100%'
  },
  '> *:not(style) + *': {
    height: 'unset'
  }
});
var Handle = /*#__PURE__*/react.styled('div', {
  width: 16,
  height: 16,
  background: 'white',
  borderRadius: '100%',
  border: '1px solid transparent',
  '&:focus': {
    outline: 'none',
    boxShadow: '0 0 0 2px rgba(0, 0, 0, 0.25)',
    borderColor: 'rgba(0, 0, 0, 1)'
  }
});
var AspectWrap = /*#__PURE__*/react.styled('div', {
  height: 0,
  position: 'relative'
});
var HandleDecoration = /*#__PURE__*/react.styled('div', {
  flex: '1 1 0%',
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  pointerEvents: 'all'
});
var HandleCanvasWrap = /*#__PURE__*/react.styled('div', {
  display: 'flex',
  '&:focus': {
    outline: 'none'
  }
});
var HandleWrap = /*#__PURE__*/react.styled('div', {
  flexShrink: 0,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  zIndex: 1
});

var DefaultHandle = function DefaultHandle(props) {
  var rest = _objectWithoutPropertiesLoose(props, _excluded);

  return React.createElement(Handle, Object.assign({}, rest));
};

var ComparisonSlider = function ComparisonSlider(_ref) {
  var itemOne = _ref.itemOne,
      itemTwo = _ref.itemTwo,
      aspectRatio = _ref.aspectRatio,
      defaultValue = _ref.defaultValue,
      value = _ref.value,
      _ref$handle = _ref.handle,
      handle = _ref$handle === void 0 ? DefaultHandle : _ref$handle,
      _ref$handleBefore = _ref.handleBefore,
      handleBefore = _ref$handleBefore === void 0 ? null : _ref$handleBefore,
      _ref$handleAfter = _ref.handleAfter,
      handleAfter = _ref$handleAfter === void 0 ? null : _ref$handleAfter,
      _ref$orientation = _ref.orientation,
      orientation = _ref$orientation === void 0 ? 'horizontal' : _ref$orientation,
      _ref$onValueChange = _ref.onValueChange,
      onValueChange = _ref$onValueChange === void 0 ? function () {} : _ref$onValueChange,
      _ref$onlyHandleDragga = _ref.onlyHandleDraggable,
      onlyHandleDraggable = _ref$onlyHandleDragga === void 0 ? false : _ref$onlyHandleDragga;

  var _React$useState = React.useState(false),
      focused = _React$useState[0],
      setFocused = _React$useState[1];

  var _React$useState2 = React.useState(defaultValue),
      localValue = _React$useState2[0],
      setLocalValue = _React$useState2[1];

  var isControlled = typeof defaultValue === 'undefined' && typeof value !== 'undefined';
  var isHorizontal = orientation === 'horizontal';
  var sliderValue = isControlled ? value : localValue;
  var padding = calculateAspectRatio(aspectRatio);
  var clipPath = isHorizontal ? "polygon(" + sliderValue + "% 0, 100% 0%, 100% 100%, " + sliderValue + "% 100%)" : "polygon(0% 100%, 0% " + (100 - sliderValue) + "%, 100% " + (100 - sliderValue) + "%, 100% 100%)";

  var handleChange = function handleChange(newValue) {
    if (isControlled) {
      onValueChange(newValue);
    } else {
      setLocalValue(newValue);
    }
  };

  var ItemOne = itemOne && isFunction(itemOne) ? itemOne({
    value: sliderValue
  }) : itemOne;
  var ItemTwo = itemTwo && isFunction(itemTwo) ? itemTwo({
    value: sliderValue
  }) : itemTwo;
  var baseSlides = [React.createElement(React.Fragment, null, ItemOne), React.createElement(React.Fragment, null, ItemTwo)];
  var direction = isHorizontal ? reactRange.Direction.Right : reactRange.Direction.Up;
  var slides = isHorizontal ? baseSlides : baseSlides.reverse();
  return React.createElement(AspectWrap, {
    style: {
      paddingBottom: padding + "%"
    }
  }, React.createElement(React.Fragment, null, slides.map(function (content, index) {
    return React.createElement(Element, {
      style: {
        clipPath: index === 1 ? clipPath : ''
      },
      key: index
    }, content);
  })), React.createElement(RangeWrap, null, React.createElement(reactRange.Range, {
    step: 1,
    min: 0,
    max: 100,
    values: [sliderValue],
    onChange: function onChange(values) {
      return handleChange(values[0]);
    },
    direction: direction,
    renderTrack: function renderTrack(_ref2) {
      var props = _ref2.props,
          children = _ref2.children;
      return React.createElement(Track, Object.assign({
        className: ""
      }, props, {
        style: _extends({}, props.style, {
          pointerEvents: onlyHandleDraggable ? 'none' : 'all'
        })
      }), children);
    },
    renderThumb: function renderThumb(params) {
      var props = _extends({}, params.props, {
        isFocused: focused
      });

      return React.createElement(HandleCanvasWrap, Object.assign({}, params.props, {
        style: _extends({}, params.props.style, {
          flexDirection: isHorizontal ? 'column' : 'row',
          height: isHorizontal ? '100%' : 'auto',
          width: isHorizontal ? 'auto' : '100%'
        }),
        onFocus: function onFocus() {
          return setFocused(true);
        },
        onBlur: function onBlur() {
          return setFocused(false);
        }
      }), React.createElement(HandleDecoration, null, handleBefore), React.createElement(HandleWrap, {
        style: {
          pointerEvents: 'all'
        }
      }, handle(props)), React.createElement(HandleDecoration, null, handleAfter));
    }
  })));
};

exports.ComparisonSlider = ComparisonSlider;
//# sourceMappingURL=react-comparison-slider.cjs.development.js.map
